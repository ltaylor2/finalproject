---
title: "Delayed Plumage Maturation Evolution in Manakins (Aves: Pipridae)"
subtitle: "Presentation Commit. 2020-12-01"
author: Liam U. Taylor
output: github_document

knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_file = "README.md",
      envir = globalenv()
    )
  })
---
```{r setup, include=FALSE}

setwd("C://Users/Liam/Documents/EEB654/finalproject")

library(tidyverse)
library(tools)
library(ape)
library(geiger)
library(phytools)
library(gridGraphics)
library(cowplot)

STAGES_FILE <- "Data/stages_all.csv"
PLUMAGE_DIR <- "Data/Plumages/"
TREE_FILE <- "Data/pipridae_jetz_10k_consensus.nex"

PLUMAGE_STATE_CODES <- c("Absent"=0,
                         "Carotenoid"=1,
                         "Melanin"=2,
                         "Structural"=3)
```

[Note: All data wrangling, analyses, and this README are produced by the fully-automated RMarkdown file located in the base directory of this repository (`finalproject.rmd`). Knit that file to reproduce this one.]

# Introduction and Goals
Organisms with deferred reproduction trade the opportunity of current reproduction for the opportunity of development while young [@stearns1992]. In birds with delayed plumage maturation (DPM), this youthful period of reproductive delay is accompanied by a drab "predefinitive" plumage during the periods when older individuals are molting into the colorful "definitive" plumages that characterize increased reproductive effort and success. Research on DPM has largely focused on functional hypotheses for the evolution of predefinitive plumage signals (i.e., three hypotheses on why it is "good to be green"). For example, the "crypsis" hypothesis suggests that drab predefinitive plumages help young males avoid predators [@selander1965; @rohwer1978] while the "social signalling" hypothesis suggests that predefinitive plumages allow young males to reduce the likelihood or costs of predation by signalling reduced reproductive capabilities [@selander1965; @lyon1986]. Studies on these function predefinitive hypotheses are limited on two fronts. First, direct benefits to instantaneous survival rate are insufficient for positive selection on the evolution of deferred reproduction, and are thus insufficient for positive selection on the "delayed maturation" part of "delayed plumage maturation" (Taylor in prep.).

Second, very little research has taken a phylogenetic view of DPM evolution. There are only two such studies. The first phylogenetic paper, by Chu [-@chu1994], found evidence that the evolution predefinitive plumages in various shorebird taxa (Aves: Charadriiformes) was the result of the evolution of juvenile plumage and the retention of an ancestral partial molt. The result is that these shorebirds retain part of their juvenile plumage in their first breeding season. This study suggests that the evolution of DPM was the result of selection on and constraints in molt timing, as opposed to selection on predefinitive plumage patches. The second phylogenetic paper, by Hill [-@hill1996], found that the presence of DPM in *Haemorhous* finches is associated with a reduction in plumage patch size. This study recommends that reduced plumage patches in these finches are themselves associated with limits in carotenoid availability, and thus that the evolution of DPM is associated with an increase in the resource costs of plumage coloration. Unlike the (conceptually limited) functional hypotheses for the evolution of predefinitive plumage signals, phylogenetic investigations have supported constraint-based hypotheses for the evolution of predefinitive plumages in association with developmental shifts.

Manakins (Aves:Passeriformes:Pipridae) are neotropical lekking birds known for their extravagant male plumages and gymnastic sexual displays [@kirwan2011]. Manakin species also vary widely in both the presence and duration of DPM [@kirwan2011; @ryder2019]. Most research into manakin predefinitive plumages has focused on the social signalling hypotheses, and ecological and behavioral results from some species indicates that DPM may play a role in cooperative interactions as young males engage in social and sexual behavior with older individuals [e.g., @mcdonald1993]. To date, there is no phylogenetic investigation of manakin DPM which broadens these taxon-specific studies. Further, the phylogenetic results of Chu [-@chu1994] and Hill [-@hill1996] cannot apply to manakins. Unlike molt-constrainted shorebirds, manakins with multiple predefinitive plumage stages have complete molts between plumages. Unlike carotenoid-restricted finches, manakins are frugivorous birds in the tropics that have ready access to food resources [@snow1971].

Thus, we have neither a family-wide view of DPM in manakins, nor an evolutionary hypothesis which can sustain one. My goal for this project is to correct this gap. For the purposes of this class, I have three explicit sub-goals: (1) Investigate the phylogenetic distribution of the presence and duration of DPM in manakins, including estimating ancestral states; (2) Identify predefinitive plumage homologs across taxa (i.e., which predefinitive plumage patches are present in the ancestral DPM stage nodes); (3) Perform comparative tests of the association between social characters and DPM evolution. The first two of these goals will hopefully open doors to additional analyses about sexual selection and discrete developmental processes in a phylogenetic context, while the third goal will directly address the standing social signalling hypotheses about DPM evolution in manakins. 

# Methods and Results

## Character Coding

I used a combination of literature reports, field guides, banding records, and photographs to code the number of DPM stages for each of 35 taxa and the distinct plumage patches at those stages. All taxa had 0, 1, 2, or 3 DPM stages, where a stage indicates an annual basic molt cycle that begins with the partial molt out of juvenal plumage [@wolfe2014]. A taxon with a DPM stage character state of 2 will generally have be in its definitive plumage only at its 4th breeding season (including its natal season), and so on. Unique partial or enduring molts that result in characteristic plumage substages (e.g., *Chiroxiphia caudata*) were collapsed into these broader annual stages. Taxa and citations are as follows:

| Taxon | Citations |
|-------|-----------|
| *Antilophia bokermanni*| [@azevedo1999; @kirwan2011; @gaiotti2016] |
| *Antilophia galeata* | [@allen1893; @marini1992; @kirwan2011 |
| *Ceratopipra	erythrocephala* | [@johnson2018] |
| *Ceratopipra	mentalis* | [@wolfe2009; @kirwan2011; @johnson2018] |
| *Chiroxiphia	caudata* | [@mallet2012] |
| *Chiroxiphia	lanceolata* | [@duval2005] |
| *Chiroxiphia	linearis* | [@doucet2007] |
| *Chiroxiphia	pareola* | [@cardenas2018] |
| *Chloropipo	flavicapilla* | [@hellmayr1926; @kirwan2011] |
| *Chloropipo	unicolor* | [@kirwan2011] |
| *Corapipo	altera* | [@jones2014] |
| *Corapipo	gutturalis* | [@prum1986; @johnson2018; @aramuni2019] |
| *Corapipo	leucorrhoa* | [@rosselli1994] |
| *Cryptopipo	holochlora* | [@wetmore1972] |
| *Heterocercus	flavivertex* | [@prum1996; @kirwan2011] |
| *Heterocercus	linteatus* | [@kirwan2011] |
| *Lepidothrix	coeruleocapilla* | [@kirwan2011] |
| *Lepidothrix	coronata* | [@ryder2005; @kirwan2011] |
| *Lepidothrix	serena* | [@prum1985; @snow2020] |
| *Lepidothrix	suavissima* | [@hilty2003; @snow2020] |
| *Lepidothrix	vilasboasi* | [@kirwan2011] |
| *Lepidothrix	nattereri* | [@kirwan2011; @snow2020] |
| *Machaeropterus	pyrocephalus* | [@hilty2003; @kirwan2011] |
| *Manacus	candei* | [@wolfe2009] |
| *Manacus	manacus* | [@johnson2018; @tu2020] |
| *Masius	chrysopterus* | [@taylor2020] |
| *Neopelma	aurifrons* | [@kirwan2011] |
| *Neopelma	pallescens* | [@kirwan2011] |
| *Pipra	aureola* | [@kirwan2011] |
| *Pipra	fasciicauda* | [@robbins1985; @kirwan2011] |
| *Pipra	filicauda* | [@ryder2005; @kirwan2011] |
| *Pseudopipra	pipra* | [@johnson2018] |
| *Tyranneutes	virescens* | [@johnson2018] |
| *Xenopipo	atronitens* | [@kirwan2011] |
| *Xenopipo	uniformis* | [@snow2020] |

I used the data from Prum [-@1994] to code two binary social characters: concentrated lekking and coordinated displays. Taxa with a 0 score for concentrated lekking included both dispersed and non-lekking states, and taxa with a 1 score for coordinated displays included all of simple, coordinated, and cooperative male-male display behaviors. I supplemented some missing taxa with updated scores based on new literature reports, but most missing data is still unavailable.

```{r wrangle stages, include=TRUE}

# A function to convert binary characters into probability distributions,
#   so that we can map missing data (NA) to a 50/50 probability across two columns
probMap <- function(v) {
  if (is.na(v)) {
    return(0.5)
  } 
  return(v)
}

# Read in the raw data matrix, concatenate taxa names,
#   convert multistate stages to binaries for correlation tests,
#   and convert unknown social states to uniform priors across two columns
stagesData <- read_csv(STAGES_FILE) %>%
          unite(Taxon, Genus, Species, sep="_") %>%
          mutate(S1Binary = as.numeric(Stages>0),
                 S2Binary = as.numeric(Stages>1),
                 S3Binary = as.numeric(Stages>2),
                 Coordinated_Present = map_dbl(Coordinated, probMap),
                 Coordinated_Absent = 1 - Coordinated_Present,
                 Concentrated_Present = map_dbl(Concentrated, probMap),
                 Concentrated_Absent = 1 - Concentrated_Present)
```

I coded predefinitive patches based on non-female- and non-juvenile-like plumage patches at each DPM stage. It is necessary to code these patches as broad visual units, rather than standardized morphological components, because patches are metamodules which are the result of covariation across barbs and barbules within and across both feathers and feather tracts [@prum2003]. Although I initially coded patches based on broad coloration method ("Carotenoid", "Melanin", "Structural"), the analyses here collapse all coloaration methods down to a binary "Present" (v. "Absent") state. Some taxa (e.g., *Corapipo* manakins at stage 1) have an all female-like predefinitive plumage stage, which corresponds to a "Absent" score for all taxa. Each taxon has an individual plumage datasheet (see .csv files in `finalproject.rmd`), which are aligned across all taxa with post-alignment missing data correctly as "Absent".

```{r wrangle plumages, include=TRUE}

# A function to parse an individual plumage record into a matrix
extractPlumageFile <- function(file) {
  taxon <- strsplit(file, "\\.")[[1]][1]

  plumage <- read_csv(paste(PLUMAGE_DIR, file, sep=""),
                        col_types = cols(.default = col_character()))

  if (nrow(plumage) == 0) {
    plumage <- bind_rows(plumage, tibble(Character="Crown", S1="Absent"))
  }
  
  plumage <- plumage %>%
          pivot_longer(-Character, 
                       names_to="Stage",
                       values_to="Value") %>%
          unite(CharacterStage, Character, Stage, sep="_") %>%
          arrange(CharacterStage) %>%
          pivot_wider(names_from=CharacterStage, 
                      values_from=Value) %>%
          purrr::map(~ PLUMAGE_STATE_CODES[.]) %>%
          as.list() %>%
          as_tibble() %>%
          mutate(Taxon=taxon, .before=1)
  
  return(plumage)
}


# Construct the plumage character matrix
plumagesData <- list.files(PLUMAGE_DIR) %>%
             purrr::map_df(extractPlumageFile)

# All patches not indicated in the original plumage tables are absent
plumagesData[is.na(plumagesData)] <- 0
```

## Backbone Phylogeny
I use a the backbone phylogeny from [BirdTree](http://birdtree.org/) [@jetz2012]. This is "supermatrix" tree which combines available genetic data with standing taxonomic information. In my case, the use of old taxonomic information results for some key edges (e.g., the placement of *Xenopipo*, *Cryptopipo*, and *Pseudopipra*). A new tree with UCE and exon genetic data from all species of manakins is in press [@leite2020] and will be used for this project if the results are made available in time for submission.

I requested a trace of 10,000 subtrees from BirdTree which were generated with the all available tips in the family Pipridae. I used [TreeAnnotator](https://beast.community/treeannotator) to collapse that tree trace into a single consensus tree for analysis here. I then prune the tree to retain only those tips for which DPM stage and predefinitive plumage characters are available.

```{r tree pruning, include=TRUE}

# Read the tree file
tree <- read.nexus(TREE_FILE)

# Refactor old taxon names which are common mislabeled across trees
refactorNames <- read_csv("Data/taxon_refactoring_names.csv")

# A function to conditionally refactor a taxon 
refactorTaxon <- function(old) {
  if (old %in% refactorNames$Taxon_Old) {
    new <- refactorNames %>%
        filter(Taxon_Old == old) %>%
        pull(Taxon_New)
    return(new)
  }
  return(old)
}
refactoredTips <- map_chr(tree$tip.label, refactorTaxon)
tree$tip.label <- refactoredTips

# Determine tips which are in the tree but not the data

treeTips <- tree$tip.label

missingTips_stages <- treeTips[!(treeTips %in% stagesData$Taxon)]
missingTips_plumages <- treeTips[!(treeTips %in% plumagesData$Taxon)]

if (length(setdiff(missingTips_stages, missingTips_plumages)) != 0) {
  stop(paste("You do not have the same tip data available for stage and plumage patches\n",
             "Here are the different tips:\n",
             paste(setdiff(treeTips_stages, treeTips_plumages), collapse="  ")))
}

treePruned <- drop.tip(tree, missingTips_stages)
```

```{r tree plot, include=FALSE}

colors <- c("0"="black", 
            "1"="green", 
            "2"="red",
            "3"="blue")

# Organize vector of stage data
stagesVector <- map_dbl(treePruned$tip.label,
                        ~ filter(stagesData, Taxon==.)$Stages[1])
names(stagesVector) <- treePruned$tip.label


png(filename="Figures/raw_tree.png", width=6, height=8, unit="in", res=400)
dotTree(treePruned, factor(stagesVector), colors=colors, fsize=1.4, ftype="reg", length=10)
dev.off()
```

The plot below shows the pruned backbone tree. Tip labels indicate DPM stage character states for each taxon.
![Dot tree with DPM stage tip labels]("Figures/raw_tree.png")


## DPM Stages: Model Selection

I used a maximum-likelihood + information-theoretic approach to evolutionary model selection for the DPM stage character. This multi-state discrete character can be modeled with a 4-state Mk model [@pagel1994]. Because this character happens to have four states within Pipridae, the resulting models resemble genetic sequence evolution models even more closely than normal.

I tested five models: 

1. Equal rates unordered
|   | 0 | 1 | 2 | 3 |
| 0 | - | A | A | A |
| 1 | A | - | A | A |
| 2 | A | A | - | A |
| 3 | A | A | A | - |

2. Equal rates ordered 

|   | 0 | 1 | 2 | 3 |
| 0 | - | A | 0 | 0 |
| 1 | A | - | A | 0 |
| 2 | 0 | A | - | A |
| 3 | 0 | 0 | A | - |

3. Equal asymmetric rates ordered

|   | 0 | 1 | 2 | 3 |
| 0 | - | A | 0 | 0 |
| 1 | B | - | A | 0 |
| 2 | 0 | B | - | A |
| 3 | 0 | 0 | B | - |

4. Unequal symmetric rates ordered

|   | 0 | 1 | 2 | 3 |
| 0 | - | A | 0 | 0 |
| 1 | A | - | B | 0 |
| 2 | 0 | B | - | C |
| 3 | 0 | 0 | C | - |

5. Unequal asymmetric rates ordered

|   | 0 | 1 | 2 | 3 |
| 0 | - | A | 0 | 0 |
| 1 | B | - | C | 0 |
| 2 | 0 | D | - | E |
| 3 | 0 | 0 | F | - |

The transition rates which maximize the likelihood of the data were estimated with the `fitMk` method in phytools [@revell2011].

```{r ace - stage - model selection, include=TRUE}

# First, we test rates models

# MODEL 1: Equal-rates unordered
fit_ER <- fitMk(tree=treePruned, x=stagesVector, model="ER")

# MODEL 2: Equal symmetric ordered
mat_eq_sym_ordered <- matrix(c(0,1,0,0,
                               1,0,1,0,
                               0,1,0,1,
                               0,0,1,0),4,4,byrow=TRUE)
fit_eq_sym_ordered <- fitMk(tree=treePruned, x=stagesVector, model=mat_eq_sym_ordered)

# MODEL 3: Equal asymmetric ordered
mat_eq_asym_ordered <- matrix(c(0,1,0,0,
                                2,0,1,0,
                                0,2,0,1,
                                0,0,2,0),4,4,byrow=TRUE)

fit_eq_asym_ordered <- fitMk(tree=treePruned, x=stagesVector, model=mat_eq_asym_ordered)
  
# MODEL 4: Unequal symmetric ordered
mat_un_sym_ordered <- matrix(c(0,1,0,0,
                               1,0,2,0,
                               0,2,0,3,
                               0,0,3,0),4,4,byrow=TRUE)

fit_un_sym_ordered <- fitMk(tree=treePruned, x=stagesVector, model=mat_un_sym_ordered)


# MODEL 5: Unequal asymmetric ordered
mat_un_asym_ordered <- matrix(c(0,1,0,0,
                                2,0,3,0,
                                0,4,0,5,
                                0,0,6,0),4,4,byrow=TRUE)

fit_un_asym_ordered <- fitMk(tree=treePruned, x=stagesVector, model=mat_un_asym_ordered)


AICs <- setNames(sapply(list(fit_ER,fit_eq_sym_ordered,fit_eq_asym_ordered,
                             fit_un_sym_ordered,fit_un_asym_ordered),AIC),
                 c("ER","eq_sym_ordered","eq_asym_ordered",
                   "un_sym_ordered","un_asym_ordered"))
```

The table below shows AIC scores for each model. The preferred model, which minimizes AIC, was the 

# UP TO HERE




```{r ace - stage - simulation, include=TRUE}
colors <- c("0"="black", 
            "1"="green", 
            "2"="red",
            "3"="blue")

maps <- make.simmap(tree=treePruned,
                    x=stagesVector,
                    model=mat_eq_sym_ordered,
                    nsim=1000)
summaries <- summary(maps)

png(filename="Figures/ace_tree.png", width=6, height=8, unit="in", res=100)
plot(summaries, colors=colors)
trash <- sapply(maps, markChanges, sapply(colors, make.transparent,0.01))
dev.off()
```
### Ancestral State Estimation: Predefinitive Plumage Patches

```{r ace - plumage - ace, include=FALSE}
# A function to generate simmap estimates for a given plumage character
simCharacter <- function(character) {
  chars <- map_dbl(treePruned$tip.label,
                   ~ filter(plumagesData, Taxon==.) %>% pull(!!character))
  
  # Convert to binary
  chars[chars > 0] <- 1
  names(chars) <- treePruned$tip.label
  
  if (all(chars==0)) {
    return(NA)
  }
  maps <- make.simmap(tree=treePruned,
                      x=chars,
                      model="ARD",
                      nsim=100)
  return(maps)
}

mapsPlumage <- purrr::map(plumageCharacters, simCharacter)
names(mapsPlumage) <- plumageCharacters
mapsPlumage <- mapsPlumage[!is.na(mapsPlumage)]
```

Plot simmaps
```{r ace - plumage plots, include=TRUE}
colors <- c("0"="gray", 
            "1"="red")

png(filename="Figures/ace_plumages.png", width=15, height=15, unit="in", res=50)
par(mfrow=c(6,6))
for (i in 1:length(mapsPlumage)) {
  densityMap(mapsPlumage[[i]], colors=colors, ftype="off", mar=c(3,3,3,0), legend=FALSE)
  title(main=plumageCharacters[i], cex.main=3)
}
dev.off()
```

```{r ace - plumage - transitions, include=FALSE}

png(filename="Figures/sims_crown_s1.png", width=4, height=4, unit="in", res=400)
densityMap(mapsPlumage[["Crown_S1"]], colors=colors, ftype="off", mar=c(3,3,3,0), legend=FALSE)
title(main="Crown_S1", cex.main=2)
dev.off()

png(filename="Figures/sims_face_s2.png", width=4, height=4, unit="in", res=400)
densityMap(mapsPlumage[["Face_S2"]], colors=colors, ftype="off", mar=c(3,3,3,0), legend=FALSE)
title(main="Face_S2", cex.main=2)
dev.off()

```

Correlated evolution

```{r correlations - stage vs. social, include=TRUE}

# First, convert stages to binary characters -- presence of each stage
stage1Binary <- map_dbl(treePruned$tip.label,
                        ~ filter(stagesData, Taxon==.)$S1Binary) 
names(stage1Binary) <- treePruned$tip.label

stage2Binary <- map_dbl(treePruned$tip.label,
                        ~ filter(stagesData, Taxon==.)$S2Binary) 
names(stage2Binary) <- treePruned$tip.label

stage3Binary <- map_dbl(treePruned$tip.label,
                        ~ filter(stagesData, Taxon==.)$S3Binary) 
names(stage3Binary) <- treePruned$tip.label

# Now get a matrix of concentrated lek trait coding
concentrated <- map_df(treePruned$tip.label,
                       ~ filter(stagesData, Taxon==.) %>% select(Concentrated_Present, Concentrated_Absent)) %>%
             as.matrix()
rownames(concentrated) <- treePruned$tip.label

# And a named matrix of coordinated display trait coding
coordinated <- map_df(treePruned$tip.label,
                      ~ filter(stagesData, Taxon==.) %>% select(Coordinated_Present, Coordinated_Absent)) %>%
            as.matrix()
rownames(coordinated) <- treePruned$tip.label

```

```{r correlations - stage vs. social, include=TRUE}
colors <- c("0"="white",
            "1"="gray",
            "2"="black")

multiTreeBinary <- map_df(treePruned$tip.label,
                           ~ filter(stagesData, Taxon==.) %>% select(S2Binary, Coordinated, Concentrated)) %>%
                as.matrix()
rownames(multiTreeBinary) <- treePruned$tip.label

multiTreeBinary <- multiTreeBinary + 1
multiTreeBinary[is.na(multiTreeBinary)] <- 0

png(filename="Figures/social_tree.png", width=6, height=6, unit="in", res=100)
dotTree(tree=treePruned, x=multiTreeBinary, colors=colors, data.type="discrete", ftype="reg", legend=FALSE)
dev.off()
```



```{r correlations - stage vs. social - Pagel test, include=TRUE}

# Perform an Mk likelihood comparison for ER vs ARD models with the binary characters
#   NOTE we cannot fit the model for the social characters themselves, because of missing data
#     (even though the fitPagel method can account for that missing data as a flat prior)

# A function to extract the AIC score from a fitMk run
tidyFitMk <- function(chars, model) {
  fit <- fitMk(tree=treePruned, x=chars, model=model)
  ll <- fit$logLik
  AIC <- AIC(fit)
  
  ret <- tibble(Model=model, lhood=ll, AIC=AIC)
  return(ret)
}

fitStage1Binary <- map_df(c("ER", "ARD"), ~ tidyFitMk(stage1Binary, .)) %>%
                mutate(Character="Stage1Binary", .before=1)

fitStage2Binary <- map_df(c("ER", "ARD"), ~ tidyFitMk(stage2Binary, .)) %>%
                mutate(Character="Stage2Binary", .before=1)

fitStage3Binary <- map_df(c("ER", "ARD"), ~ tidyFitMk(stage3Binary, .)) %>%
                mutate(Character="Stage3Binary", .before=1)

fitsStagesBinary <- bind_rows(fitStage1Binary, fitStage2Binary, fitStage3Binary) %>%
                 group_by(Character) %>%
                 filter(AIC == min(AIC))
```


```{r correlations - stage vs. social - Pagel test, include=TRUE}

dependencyKey <- function(d) {
  if (d == "x") {
    return("X<-Y")
  } else if (d == "y") {
    return("X->Y")
  } else if (d == "xy") {
    return ("X<->Y")
  }
  return("ERROR")
}

# A function to extract key results from the fitPagel discrete correlation test
tidyFitPagel <- function(x, y, model, dep) {
  results <- fitPagel(tree=treePruned,
                      x=x,
                      y=y,
                      method="fitMk",
                      dep.var=dep,
                      model=model)
  ret <- tibble(model=model, p=results$P,
                AIC_ind=results$independent.AIC, AIC_dep=results$dependent.AIC) %>%
      mutate(dAIC = AIC_dep - AIC_ind,
             Dependency = map_chr(dep, dependencyKey))
  return(ret)
}

# Gone fishing
corrs_S1_Concentrated <- map_df(c("xy", "x", "y"), ~ tidyFitPagel(stage1Binary, concentrated, "ER", .)) %>%
                      mutate(Social="Concentrated", .before=1) %>%
                      mutate(Stage="S1", .before=2)

corrs_S2_Concentrated <- map_df(c("xy", "x", "y"), ~ tidyFitPagel(stage2Binary, concentrated, "ER", .)) %>%
                      mutate(Social="Concentrated", .before=1) %>%
                      mutate(Stage="S2", .before=2)

corrs_S3_Concentrated <- map_df(c("xy", "x", "y"), ~ tidyFitPagel(stage3Binary, concentrated, "ER", .)) %>%
                      mutate(Social="Concentrated", .before=1) %>%
                      mutate(Stage="S3", .before=2)

corrs_Concentrated <- bind_rows(corrs_S1_Concentrated, corrs_S2_Concentrated, corrs_S3_Concentrated)


corrs_S1_Coordinated <- map_df(c("xy", "x", "y"), ~ tidyFitPagel(stage1Binary, coordinated, "ER", .)) %>%
                      mutate(Social="Coordinated", .before=1) %>%
                      mutate(Stage="S1", .before=2)

corrs_S2_Coordinated <- map_df(c("xy", "x", "y"), ~ tidyFitPagel(stage2Binary, coordinated, "ER", .)) %>%
                      mutate(Social="Coordinated", .before=1) %>%
                      mutate(Stage="S2", .before=2)

corrs_S3_Coordinated <- map_df(c("xy", "x", "y"), ~ tidyFitPagel(stage3Binary, coordinated, "ER", .)) %>%
                      mutate(Social="Coordinated", .before=1) %>%
                      mutate(Stage="S3", .before=2)

corrs_Coordinated <- bind_rows(corrs_S1_Coordinated, corrs_S2_Coordinated, corrs_S3_Coordinated)

corrs <- bind_rows(corrs_Concentrated, corrs_Coordinated)
```

```{r correlations - tables, echo=TRUE}
coevolutions <- corrs %>%
             filter(Dependency == "X<->Y") %>%
             select(-model)

kbl(coevolutions, digits=2) %>%
  kable_classic(full_width=FALSE, font_size=20, html_font="Arial")

sigCorrs <- corrs %>%
         filter(Dependency != "X<->Y", p <= 0.05) %>%
         select(-model)

kbl(sigCorrs, digits=2) %>%
  kable_classic(full_width=FALSE, font_size=20, html_font="Arial")
```


# Discussion and Conclusion

# References